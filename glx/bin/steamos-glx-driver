#!/bin/bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
# vim: et sts=4 sw=4

#  SPDX-License-Identifier: LGPL-2.1+
#
#  Copyright © 2019 Collabora Ltd.
#  Copyright © 2019 Valve Corporation.
#
#  This file is part of steamos-customizations.
#
#  steamos-customizations is free software; you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published
#  by the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

set -eu;

export LC_ALL=C;
export LANG=C;

initrd=;
module_list=;
nvidia_module=;
dracut_conf=/etc/dracut.conf.d/99-nvidia-dkms.conf;

log ()
{
    local pfx=$1; shift;

    if [ -t 1 ]; then pfx=''; fi;
    echo "$pfx$@";
}

info   () { log "<6>" "$@"; }
notice () { log "<5>" "$@"; echo "$@" > /dev/console; }
warn   () { log "<4>" "$@"; echo "$@" > /dev/console; }

get_initrd ()
{
    local ver=$1;
    local pkgbase=/usr/lib/modules/$(uname -r)/pkgbase;
    
    initrd=;
    if [ -e "$pkgbase" ];
    then
        initrd="/boot/initramfs-$(<$pkgbase).img";
    else
	initrd="/boot/initrd.img-$ver";
    fi;
}

get_nvidia_module ()
{
    nvidia_module=;
    if [ -e /etc/arch-release ];
    then
        nvidia_module="nvidia";
    else
	nvidia_module="nvidia-current";
    fi;
}

get_module_list ()
{
    local mod=$1;
    local ver=$2;
    local krn=${3:-$(uname -r)};
    local arc=${4:-$(uname -m)};
    local modpath=/var/lib/dkms/"$mod/$ver/$krn/$arc"/module;

    module_list=;
    module_list=$(ls -1 "$modpath" | sed -E 's/\.ko(\.xz)*$//');
}

initrd_is_up_to_date ()
{
    local initrd=$1; shift;
    local mod=$1;    shift;
    local ver=$1;    shift;
    local krn=$1;    shift;
    local arc=$1;    shift;

    local imod=;
    local allmods=;
    local update=;
    local modpath=/var/lib/dkms/"$mod/$ver/$krn/$arc"/module;
    declare -A found;

    while read l;
    do
        imod=$(echo "${l##*/}" | sed -E 's/\.ko(\.xz)*$//');
        for m in "$@";
        do
            if [ "$imod" = "$m" ]; then found[$m]=1; fi;
        done;
    done < <(lsinitrd "$initrd" | grep -E '\.ko(\.xz)*$');

    allmods=1;
    for m in "$@";
    do
        if [ ${found[$m]:-0} = 1 ]; then continue; fi;
        allmods=0;
    done;

    if [ $allmods = 0 ];
    then
        info "Module list in $initrd incomplete:";
        for m in "$@";
        do
            if [ ${found[$m]:-0} != 1 ];
            then
                info "  Missing: $m";
            fi;
        done;
        update=1;
    else
        update=0;
        for m in "$@";
        do
            imod="$m".ko;
            if ! [ -e "$modpath"/"$imod" ];
            then
                imod="$imod".xz;
            fi;
            if ! [ -e "$modpath"/"$imod" ];
            then
                info "Module $m not found in $modpath";
                continue;
            fi;
            if [ "$modpath"/"$imod" -nt "$initrd" ];
            then
                info "Initrd module $imod is out of date";
                update=1;
            fi;
        done;
    fi;

    if [ $update = 0 ];
    then
        return 0;
    fi;

    return 1;
}

check_nvidia_dkms_modules ()
{
    local mod=;
    local ver=;
    local krn=;
    local arc=;
    local sta=;
    local xxx=;
    local regen=noop;
    local kernel=${1:-$(uname -r)};

    get_nvidia_module;
    local oIFS="$IFS";
    IFS="$IFS:,";
    read mod ver krn arc sta xxx < <(dkms status $nvidia_module);
    if [ -z "$sta" ]; then sta=$krn; krn=; fi;

    case $mod:$sta in
        $nvidia_module:installed)
            info "$nvidia_module module is built";
            regen=no;
            ;;
        $nvidia_module:*)
            info "$nvidia_module module needs to be built";
            regen=yes;
            ;;
    esac;
    IFS="$oIFS";

    case $regen in
        yes)
            notice "Rebuilding dkms modules $mod/$ver";
            dkms build "$mod"/"$ver";
            IFS="$IFS:,";
            read mod ver krn arc sta xxx < <(dkms status $nvidia_module);
            if [ -z "$sta" ]; then sta=$krn; krn=; fi;
            IFS="$oIFS";
            ;;
        no)
            true;
            ;;
        *)
            rm -f ${dracut_conf:-/etc/dracut.conf.d/no-such-file};
            ;;
    esac;

    # regen=noop means nothing else to do
    if [ $regen = noop ]; then return 0; fi;

    # even if regen was no we might need to update the initrd
    get_module_list $mod $ver $krn $arc;
    echo -n > $dracut_conf;
    for m in $module_list;
    do
        info "Adding $m to dracut config";
        echo "add_drivers+=\" $m \"" >> $dracut_conf;
    done;

    get_initrd $ver;
    if initrd_is_up_to_date "$initrd" "$mod" "$ver" "$krn" "$arc" $module_list;
    then
        info "Initrd has up to date $mod/$ver:" $module_list;
        return 0;
    fi;

    if [ "$sta" = installed ];
    then
        notice "Rebuilding initrd to install $mod/$ver:" $module_list;
        dracut -f "$initrd";
    else
        notice "Installing $mod/$ver:" $module_list;
        dkms install "$mod"/"$ver";
        # DKMS can rebuild the initrd as part of 'dkms install',  if ever
        # REMAKE_INITRD is set.  The only probem is that we don't know if
        # this option was set (could be added in a conf file by the user).
        # So the only way to know whether we need to rebuild the initrd,
        # AFAICT, is to call initrd_is_up_to_date() a second time. Too bad
        # it's such an expensive operation (lsinitrd under the hood)...
        if ! initrd_is_up_to_date "$initrd" "$mod" "$ver" "$krn" "$arc" $module_list;
        then
            notice "Rebuilding initrd to install $mod/$ver:" $module_list;
            dracut -f "$initrd";
        fi;
    fi;

    # Reboot now. It would be better to ask systemd to go to the end of the
    # current target (ie. sysinit.target) and reboot, but couldn't find how...
    warn "Rebooting in 5 seconds...";
    sleep 5s;
    reboot;
}

case ${1:-} in
    *\ nvidia\ *|nvidia) check_nvidia_dkms_modules; ;;
    *) exit 0; ;;
esac;
